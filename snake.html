<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>@snake###</title>
    </head>
    <body>
        <pre>
/*

@snake###

"@" is the head, "#"s are the body
all letters are fruits
use arrows to control the snake
use space to pause the game
change field size and speed in html
current score is <span id="score">0</span>

*/
        </pre>
        <pre id="field"></pre>
        <style>body { text-align: center; }</style>
        <script>
            const main = () => {
                const size = 8;
                const initialMoveDelay = 500;
                const minMoveDelay = 200;

                const moveDelayDelta = initialMoveDelay - minMoveDelay;
                const emptyField = Array(size)
                    .fill(null)
                    .map(row => Array(size).fill(null));

                const getCurrentMoveDelay = score =>
                    initialMoveDelay -
                    moveDelayDelta * (score / (size ** 2 - 1));

                const getNewHead = ([curRow, curCell], direction) => {
                    if (direction === 'r') {
                        let newCell = curCell + 1;
                        if (newCell === emptyField[0].length) newCell = 0;
                        return [curRow, newCell];
                    } else if (direction === 'l') {
                        let newCell = curCell - 1;
                        if (newCell < 0) newCell = emptyField[0].length - 1;
                        return [curRow, newCell];
                    } else if (direction === 'b') {
                        let newRow = curRow + 1;
                        if (newRow === emptyField.length) newRow = 0;
                        return [newRow, curCell];
                    } else if (direction === 't') {
                        let newRow = curRow - 1;
                        if (newRow < 0) newRow = emptyField.length - 1;
                        return [newRow, curCell];
                    } else {
                        throw new Error(`Unknown direction ${direction}`);
                    }
                };

                const isValidDirection = (...directions) => {
                    return !(
                        directions[0] === directions[1] ||
                        directions.every(d => ['l', 'r'].includes(d)) ||
                        directions.every(d => ['t', 'b'].includes(d))
                    );
                };

                const copyField = field => [...field.map(arr => [...arr])];

                const renderField = field => {
                    const fieldString = field
                        .map(arr =>
                            arr.map(val => (val === null ? '.' : val)).join(' ')
                        )
                        .join('\n');
                    document.getElementById('field').textContent = fieldString;
                };

                const renderScore = score =>
                    (document.getElementById('score').textContent = score);

                const randomUpTo = max => Math.floor(Math.random() * max);

                const getUnoccupiedCell = fieldWithSnake => {
                    const options = [];
                    for (let rowI = 0; rowI < fieldWithSnake.length; rowI++) {
                        for (
                            let cellI = 0;
                            cellI < fieldWithSnake[0].length;
                            cellI++
                        ) {
                            if (fieldWithSnake[rowI][cellI]) continue;
                            options.push([rowI, cellI]);
                        }
                    }
                    return options[randomUpTo(options.length)];
                };

                const fruits =
                    'YOUAREAMAZINGSTRONGBRAVEANDWONDERFULREMEMBERTHATTODAY';
                const getRandomFruit = score => fruits[score % fruits.length];

                let score = 0;
                let timeoutId;
                let direction = 'r';
                let fieldWithoutSnake = copyField(emptyField);
                const snake = [getUnoccupiedCell(fieldWithoutSnake)];

                document.body.onkeydown = ev => {
                    if (timeoutId) {
                        if (ev.key === ' ') {
                            clearTimeout(timeoutId);
                            timeoutId = undefined;
                            return;
                        }
                        const newDirection = {
                            ArrowRight: 'r',
                            ArrowLeft: 'l',
                            ArrowUp: 't',
                            ArrowDown: 'b'
                        }[ev.key];

                        if (
                            newDirection &&
                            isValidDirection(direction, newDirection)
                        )
                        direction = newDirection;
                        return;
                    }
                    if (ev.key === ' ') timeoutId = setTimeout(makeMove, getCurrentMoveDelay(score));
                };

                const makeMove = (forceCreateFruit = false) => {
                    const fieldWithSnake = copyField(fieldWithoutSnake);
                    const [headRow, headCell] = getNewHead(snake[0], direction);
                    const newHead = fieldWithoutSnake[headRow][headCell];
                    let ateFruit = false;
                    if (newHead) {
                        ateFruit = true;
                        score++;
                        renderScore(score);
                        fieldWithoutSnake[headRow][headCell] = null;
                    }

                    if (!ateFruit) snake.pop();
                    snake.unshift([headRow, headCell]);

                    let isFirst = true;
                    for (const [blockRow, blockCell] of snake) {
                        if (fieldWithSnake[blockRow][blockCell] === '@') {
                            if (
                                confirm(
                                    `Game over. Score: ${score}! Try again?`
                                )
                            )
                                main();
                            return;
                        }
                        fieldWithSnake[blockRow][blockCell] = isFirst
                            ? '@'
                            : '#';
                        isFirst = false;
                    }

                    if (forceCreateFruit || ateFruit) {
                        const fruitLocation = getUnoccupiedCell(fieldWithSnake);
                        if (!fruitLocation) {
                            if (confirm(`You won. Score: ${score}! Try again?`))
                                main();
                            return;
                        }
                        const [rowI, cellI] = fruitLocation;
                        const fruit = getRandomFruit(score);
                        fieldWithoutSnake[rowI][cellI] = fruit;
                        fieldWithSnake[rowI][cellI] = fruit;
                    }

                    renderField(fieldWithSnake);

                    timeoutId = setTimeout(
                        makeMove,
                        getCurrentMoveDelay(score)
                    );
                };

                makeMove(true);
            };
            main();
        </script>
    </body>
</html>
